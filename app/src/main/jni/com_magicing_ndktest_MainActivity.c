/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <android/native_activity.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>
#include <android/log.h>
#include <android/bitmap.h>
#include <stdio.h>
#include <setjmp.h>


#include "include/libjpeg-turbo/jpeglib.h"
#include "include/libjpeg-turbo/cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include "include/libjpeg-turbo/jversion.h"		/* for version message */
#include "include/libjpeg-turbo/android/config.h"


//为了方便调用，将输出宏定义
#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, "threaded_app", __VA_ARGS__))
#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, "threaded_app", __VA_ARGS__))

/* For debug builds, always enable the debug traces in this library */
#ifndef NDEBUG
#  define LOGV(...)  ((void)__android_log_print(ANDROID_LOG_VERBOSE, "threaded_app", __VA_ARGS__))
#else
#  define LOGV(...)  ((void)0)
#endif


/*
 * Class:     com_magicing_ndktest_MainActivity
 * Method:    showJPG
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT void JNICALL Java_com_magicing_ndktest_utils_NDKMethod_showJPG
  (JNIEnv *env, jobject obj, jobject surface, jstring img){
    const char * imgChar;
       jboolean * isCopy;
       //imgChar = env->GetStringUTFChars(img, 0);
       imgChar =(*env)->GetStringUTFChars(env, img, 0);
       ANativeWindow_Buffer nwBuffer;

       LOGI("img path : %s  ",imgChar);

       LOGI("ANativeWindow_fromSurface ");
       ANativeWindow * mANativeWindow = ANativeWindow_fromSurface(env, surface);

       if (mANativeWindow == NULL) {
           LOGE("ANativeWindow_fromSurface error");
           return;
       }

       LOGI("ANativeWindow_lock ");
       if (0 != ANativeWindow_lock(mANativeWindow, &nwBuffer, 0)) {
           LOGE("ANativeWindow_lock error");
           return;
       }

       read_jpeg_file_show(imgChar, &nwBuffer);

       if (nwBuffer.format == WINDOW_FORMAT_RGBA_8888) {
           LOGI("nwBuffer->format == WINDOW_FORMAT_RGBA_8888 ");
       }

       LOGI("ANativeWindow_unlockAndPost ");
       if (0 != ANativeWindow_unlockAndPost(mANativeWindow)) {
           LOGE("ANativeWindow_unlockAndPost error");
           return;
       }

       //env->ReleaseStringUTFChars(img,imgChar);
       (*env)->ReleaseStringUTFChars(env, img, imgChar);
       ANativeWindow_release(mANativeWindow);

       LOGI("ANativeWindow_release ");
       return;
 }

int read_jpeg_file_show(const char *input_filename, ANativeWindow_Buffer *nwBuffer) {
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    FILE *input_file;
    JSAMPARRAY buffer;
    int row_width;

    unsigned char *buffertmp;

    cinfo.err = jpeg_std_error(&jerr);

    if ((input_file = fopen(input_filename, "rb")) == NULL) {
        fprintf(stderr, "can't open %s\n", input_filename);
        LOGI("can't open jpg1");
        return -1;
    }

    //初始化信息
    jpeg_create_decompress(&cinfo);
    LOGI("初始化信息");

    /* Specify data source for decompression */
    //指定图片
    jpeg_stdio_src(&cinfo, input_file);
    LOGI("指定图片");

    /* Read file header, set default decompression parameters */
    (void) jpeg_read_header(&cinfo, TRUE);
    LOGI("读取头信息, set default decompression parameters ");

    /* Start decompressor */
    (void) jpeg_start_decompress(&cinfo);
    LOGI("解压");

    row_width = cinfo.output_width * cinfo.output_components;
    LOGI("图片的宽:%d 图片的高%d 颜色长度:%d", cinfo.output_width, cinfo.output_height, cinfo.output_components);

    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE,
            row_width, 1);

    //一行
    //buffertmp = (unsigned char *) malloc(row_width);
    //memset(buffertmp, 0, row_width);

    LOGI("malloc and memset");
//        tmp = output_buffer;

    /* Process data */
    int get8h5 = 248, get8h6 = 252;
    __uint16_t * line = (__uint16_t *) nwBuffer->bits;
    int wheight = 0;

    int scalew = 1, scaleh = 1;

    if (cinfo.output_width > nwBuffer->width) {
        scalew = cinfo.output_width / nwBuffer->width;
    }

    LOGI(" scale of img = %d", scalew);

     int i=0;
     int choosehNum=0;
    for ( i= 0, choosehNum = 0; i < cinfo.output_height; i++) {
        //获得一行
        jpeg_read_scanlines(&cinfo, buffer, 1);
        buffertmp = *buffer;
        //根据缩放选取行
        if (i % scalew == 0 && choosehNum++ < nwBuffer->height) {

            //LOGI("nwBuffer->format == WINDOW_FORMAT_RGB_565");
            int j=0;
            int choosewNum =0;
            for (j = 0, choosewNum = 0; j < cinfo.output_width; j++) {
                if (j % scalew == 0) {
                    if (nwBuffer->format == WINDOW_FORMAT_RGB_565) {
                        line[choosewNum] = ((__uint16_t ) buffertmp[3 * j + 0]
                                & get8h5) << 8
                                | ((__uint16_t ) (buffertmp[3 * j + 1] & get8h6)
                                        << 3)
                                | ((__uint16_t ) (buffertmp[3 * j + 2] & get8h6)
                                        >> 3);
                        choosewNum++;
                    }
                }

            }
            line = line + nwBuffer->stride;
        }
    }

//                memcpy(tmp, *buffer, row_width);
//                tmp += row_width;

    (void) jpeg_finish_decompress(&cinfo);
    LOGI("jpeg_finish_decompress !!");

    jpeg_destroy_decompress(&cinfo);
    LOGI("jpeg_destroy_decompress !!");

    /* Close files, if we opened them */
    fclose(input_file);

    //free(buffertmp);

    return 0;
}


JNIEXPORT void JNICALL Java_com_magicing_ndktest_utils_NDKMethod_showImage
        (JNIEnv *env, jobject obj, jobject surface, jstring path){
    const char * imgChar;
    jboolean * isCopy;
    
    imgChar =(*env)->GetStringUTFChars(env, path, 0);
    ANativeWindow_Buffer nwBuffer;

    LOGI("img path : %s  ",imgChar);

    LOGI("ANativeWindow_fromSurface ");
    ANativeWindow * mANativeWindow = ANativeWindow_fromSurface(env, surface);


    return;
}